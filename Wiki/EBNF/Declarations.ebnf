Module = { Statement };

(* Wait statements only valid within Stimulus and Emulate blocks *)
Statement  = [ Wait ]
             ( Definition | ClassDefinition | EnumDefinition
           | Alias | Import | Struct | Group | AccessDirectionGroup
           | IfStatement | For | While  | Loop | Switch | Case | Jump
           | FunctionCallStatement | NamespacePush | Assignment
           | RTL | FSM | HDL
           | Stimulus | Emulate | ForkJoin | SequenceDef | Assert
           | CoverBins | CoverGroup | ";" );

(* Inline only applies to function definitions *)
Definition = [ "inline" ] ( BaseType | ScopedIdentifier ) [ ParameterList ]
             [ AttributeList ] ( VariableDefList | FunctionDef | OperatorOverload );

ClassDefinition = "class" [ AttributeList ] Identifier
                  [ "(" [ ParameterDefList ] ")" ]
                  [
                    ":" ScopedIdentifier [ ParameterList ]
                  { "," ScopedIdentifier [ ParameterList ] }
                  ]
                  "{" { Statement } "}";

(* Only useful within a class body *)
AccessDirectionGroup = ( ( AccessSpecifier [ DirectionSpecifier ] ) |
                         ( DirectionSpecifier ) ) StatementBlock;
AccessSpecifier    = "public" | "private" | "protected";
DirectionSpecifier = "input" | "output";

BaseType = "pin"  | "net"          (* Synthesisable types *)
         | "void" | "auto"         (* Used as function return types *)
         | "byte" | "char" | "num" (* Scripting types     *)
         | "func" ;                (* Function pointer    *)

VariableDefList  = VariableDef { "," VariableDef } ";";
VariableDef      = Identifier { ArrayDefinition } [ Initialiser ];
FunctionDef      = ( Identifier { ArrayDefinition } )
                   "(" [ ParameterDefList ] ")"
                   "{" { Statement } "}" ;
OperatorOverload = ( "operator" Operator )
                   "(" [ ParameterDefList ] ")"
                   "{" { Statement } "}" ;

ArrayDefinition  = "[" [ Expression ] "]";
Initialiser      = ( "=" | ":=" ) Expression;

ParameterDefList = ParameterDef { "," ParameterDef } [ "," ];
ParameterDef     = [ ( BaseType | ScopedIdentifier ) [ ParameterList ] ]
                   Identifier { "[" "]" } [ Initialiser ];

AttributeList       = "<" AttributeAssignment { "," AttributeAssignment } [ "," ] ">";
AttributeAssignment = Identifier "=" Primary;

EnumDefinition = "enum" [ AttributeList ] Identifier "{" EnumMemberDef { "," EnumMemberDef } [ "," ] "}";
EnumMemberDef  = Identifier [ "=" Expression ];

ScopedIdentifier = Identifier { "." Identifier }; (* NameSpace.Name *)
(*----------------------------------------------------------------------------*)

